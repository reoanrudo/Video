# 1. 問題の概要
- 既存機能の描画ツールが動画再生後に反映されず線が引けない。
- 環境: ローカル（localhost）。
- 期待動作: 動画再生後もキャンバス上で線や図形を描画できること。

# 2. 発生している事象
- コンソールに `RangeError: Maximum call stack size exceeded` が大量発生（`app-CHqJATuo.js:1`）。
- 発生手順（ユーザー提供）: ローカル環境で動画を再生 → 描画ツールで線を引こうとするとエラーが出て反映しない。

# 3. 調査内容と観察結果
- 対象ビルドファイル: `public/build/assets/app-CHqJATuo.js`。
- 同ファイル内でキャンバスサイズ同期用関数 `oe` が末尾で `T()` を呼び出している。
- `T` は `() => { oe(), dt() }` と定義され、`oe` → `T` → `oe`… の相互再帰が無限ループを形成。`oe` 内部の `Math.round` がスタックオーバーフローの先頭に出ており、コンソールエラーと一致。
- `dt` はレンダラー（`Renderer`）呼び出し相当。`oe` は `syncCanvasSize`、`T` はマークダーティ相当の関数としてバンドル時に生成されたものとみられる。
- 元ソース `resources/js/editor/index.js` では `syncCanvasSize()` 内で `markDirty()` を呼び、`markDirty` は `renderer()` を呼ぶだけだが、ビルド結果では `markDirty` 相当が `syncCanvasSize` を再度呼ぶ形に崩れており、ビルド後コードで無限再帰が発生している。

# 4. 原因の仮説
- ビルド／最適化過程で `syncCanvasSize()` と `markDirty()` をまとめたヘルパー `T` が生成され、`syncCanvasSize` 側にも `T()` 呼び出しが残ったことで相互再帰が発生した。
- 入口は `markDirty` 呼び出し箇所全般（描画ツール操作、リサイズイベント、キーフレーム操作など）。呼ばれた瞬間にスタックオーバーフローが発生し描画が止まる。

# 5. 影響範囲
- 描画ツールの全操作（線、矢印、ペンなど）が `markDirty` に依存するため実質全滅。
- リサイズイベントでも同じ関数が呼ばれるため、動画読み込み直後やウィンドウ操作でも発火する可能性あり。
- 保存・キーフレーム操作も再描画を伴うため、同様にエラーに遭遇するリスクが高い。

# 6. 今後の対応メモ（方針）
- `resources/js/editor/index.js` で `syncCanvasSize()` 末尾の `markDirty()` 呼び出しを外し、リサイズハンドラなど必要箇所で明示的に `markDirty()` を呼ぶ形に分離して再ビルドする、または `markDirty` を `renderer` のみ呼ぶ軽量関数に固定し、バンドラが `syncCanvasSize` を再帰させない構造にする。
- 修正後 `vite build` を行い `public/build/assets/app-*.js` を確認し、`oe` → `T` → `oe` の相互呼び出しがなくなっていることを確認。
- 動作確認: ローカルで動画を読み込み → 再生 → 描画ツールで線を引く → コンソールにエラーが出ないことを確認。
